<Project>

  <PropertyGroup>
    <!-- Since we want to default to remote hot reload on non-desktop runtimes, we first need to determine whether we are dealing with one. -->
    <_HotAvaloniaIsAndroid>$(TargetFramework.EndsWith('-android'))</_HotAvaloniaIsAndroid>
    <_HotAvaloniaIsIOS>$(TargetFramework.EndsWith('-ios'))</_HotAvaloniaIsIOS>
    <_HotAvaloniaIsBrowser>$(TargetFramework.EndsWith('-browser'))</_HotAvaloniaIsBrowser>
    <_HotAvaloniaIsNotDesktop Condition="'$(_HotAvaloniaIsNotDesktop)' == '' And ('$(_HotAvaloniaIsAndroid)' == 'true' Or '$(_HotAvaloniaIsIOS)' == 'true' Or '$(_HotAvaloniaIsBrowser)' == 'true')">true</_HotAvaloniaIsNotDesktop>
    <_HotAvaloniaIsNotDesktop Condition="'$(_HotAvaloniaIsNotDesktop)' == ''">false</_HotAvaloniaIsNotDesktop>

    <!-- Some dependencies only make sense for startup projects that produce the actual executable. -->
    <!-- Note that there's a "feature" that sets `OutputType` to `Library` for non-desktop runtimes, regardless of the actual setting. -->
    <!-- Thus, this scenario needs to be handled separately. -->
    <_HotAvaloniaIsExe Condition="'$(_HotAvaloniaIsExe)' == '' And '$(_HotAvaloniaIsNotDesktop)' == 'true'">true</_HotAvaloniaIsExe>
    <_HotAvaloniaIsExe Condition="'$(_HotAvaloniaIsExe)' == ''">$(OutputType.ToLowerInvariant().EndsWith('exe'))</_HotAvaloniaIsExe>

    <!-- `MonoMod`, which we use for injection-based hot reload, only works on x64 systems. -->
    <!-- Therefore, we need to determine the architecture of the current machine. -->
    <_HotAvaloniaIsX64 Condition="'$(_HotAvaloniaIsX64)' == '' And '$([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture)' == 'X64'">true</_HotAvaloniaIsX64>
    <_HotAvaloniaIsX64 Condition="'$(_HotAvaloniaIsX64)' == ''">false</_HotAvaloniaIsX64>

    <!-- `.vbproj` uses `,` to separate constants defined via `DefineConstants` instead of `;`. -->
    <!-- The funny thing is, MSBuild will throw an error if you try to use `;` because it's a forbidden character. -->
    <!-- So, this mf understands what you want, but instead of interpreting `;` as a separator, it still decides to crash. -->
    <!-- Thanks for that, I guess. -->
    <_HotAvaloniaDefineConstantsSeparator Condition="'$(_HotAvaloniaDefineConstantsSeparator)' == '' And '$(MSBuildProjectExtension)' == '.vbproj'">,</_HotAvaloniaDefineConstantsSeparator>
    <_HotAvaloniaDefineConstantsSeparator Condition="'$(_HotAvaloniaDefineConstantsSeparator)' == ''">;</_HotAvaloniaDefineConstantsSeparator>

    <!-- We primarily need these constants so we can redefine them locally for testing purposes. -->
    <_HotAvaloniaHarfsFile Condition="'$(_HotAvaloniaHarfsFile)' == ''">$(MSBuildThisFileDirectory)..\tools\HotAvalonia.Remote.dll</_HotAvaloniaHarfsFile>
    <_HotAvaloniaAssemblyFile Condition="'$(_HotAvaloniaAssemblyFile)' == ''">$(MSBuildThisFileDirectory)..\tasks\netstandard2.0\HotAvalonia.dll</_HotAvaloniaAssemblyFile>
    <_HotAvaloniaCoreProjectFile Condition="'$(_HotAvaloniaCoreProjectFile)' == ''"></_HotAvaloniaCoreProjectFile>
    <_HotAvaloniaExtensionsFile Condition="'$(_HotAvaloniaExtensionsFile)' == ''"></_HotAvaloniaExtensionsFile>
    <_HotAvaloniaWeaverFiles Condition="'$(_HotAvaloniaWeaverFiles)' == ''"></_HotAvaloniaWeaverFiles>
  </PropertyGroup>

  <!-- Import our tasks from the `HotAvalonia` assembly. -->
  <UsingTask TaskName="HotAvalonia.GenerateFileSystemServerConfigTask" AssemblyFile="$(_HotAvaloniaAssemblyFile)" />
  <UsingTask TaskName="HotAvalonia.GetFileSystemClientConfigTask" AssemblyFile="$(_HotAvaloniaAssemblyFile)" />
  <UsingTask TaskName="HotAvalonia.StartFileSystemServerTask" AssemblyFile="$(_HotAvaloniaAssemblyFile)" />

  <PropertyGroup>
    <!-- Enable `HotAvalonia` for debug builds by default. -->
    <HotAvalonia Condition="'$(HotAvalonia)' == 'enable'">true</HotAvalonia>
    <HotAvalonia Condition="'$(HotAvalonia)' == '' And '$(Configuration)' == 'Debug'">true</HotAvalonia>
    <HotAvalonia Condition="'$(HotAvalonia)' == ''">false</HotAvalonia>

    <!-- Default to remote hot reload for non-desktop builds. -->
    <HotAvaloniaRemote Condition="'$(HotAvaloniaRemote)' == 'enable'">true</HotAvaloniaRemote>
    <HotAvaloniaRemote Condition="'$(HotAvaloniaRemote)' == ''">$(_HotAvaloniaIsNotDesktop)</HotAvaloniaRemote>

    <!-- Default to lite hot reload when remote hot reload is enabled. -->
    <HotAvaloniaLite Condition="'$(HotAvaloniaLite)' == 'enable'">true</HotAvaloniaLite>
    <HotAvaloniaLite Condition="'$(HotAvaloniaLite)' == ''">$(HotAvaloniaRemote)</HotAvaloniaLite>

    <!-- We want (need) to add `AvaloniaHotReloadExtensions` only to startup projects. -->
    <HotAvaloniaIncludeExtensions Condition="'$(HotAvaloniaIncludeExtensions)' == ''">$(_HotAvaloniaIsExe)</HotAvaloniaIncludeExtensions>

    <!-- The auto-enable feature only works (and only makes sense) in the context of startup projects that produce an actual executable. -->
    <HotAvaloniaAutoEnable Condition="'$(HotAvaloniaAutoEnable)' == ''">$(_HotAvaloniaIsExe)</HotAvaloniaAutoEnable>

    <!-- We want this feature to always be enabled by default since there's no harm in it. -->
    <!-- Worst case, it will just do nothing. -->
    <HotAvaloniaRecompileResources Condition="'$(HotAvaloniaRecompileResources)' == ''">true</HotAvaloniaRecompileResources>

    <!-- This switch tweaks the behavior of the auto-enable feature, so there's no reason to enable it when the feature itself is disabled. -->
    <!-- However, when enabled, we want it ON by default. -->
    <HotAvaloniaGeneratePathResolver Condition="'$(HotAvaloniaGeneratePathResolver)' == ''">$(HotAvaloniaAutoEnable)</HotAvaloniaGeneratePathResolver>

    <!-- Since `MonoMod` only supports x64, we want to disable it for all other architectures. -->
    <!-- Note that if remote hot reload is enabled, we cannot reliably determine the architecture of the target device. -->
    <HotAvaloniaUseInjections Condition="'$(HotAvaloniaUseInjections)' == '' And '$(HotAvaloniaRemote)' != 'true'">$(_HotAvaloniaIsX64)</HotAvaloniaUseInjections>
    <HotAvaloniaUseInjections Condition="'$(HotAvaloniaUseInjections)' == ''">false</HotAvaloniaUseInjections>
  </PropertyGroup>

  <PropertyGroup>
    <!-- Let the task to infer the local address of the machine. -->
    <HarfsAddress Condition="'$(HarfsAddress)' == ''"></HarfsAddress>

    <!-- If no network interface is available, default to `127.0.0.1`. -->
    <!-- However, if our target is an Android emulator, use `10.0.2.2` instead, -->
    <!-- as this address is directly mapped to the host machine's localhost. -->
    <HarfsFallbackAddress Condition="'$(HarfsFallbackAddress)' == '' And '$(_HotAvaloniaIsAndroid)' == 'true'">10.0.2.2</HarfsFallbackAddress>
    <HarfsFallbackAddress Condition="'$(HarfsFallbackAddress)' == ''">127.0.0.1</HarfsFallbackAddress>

    <!-- Default to listening on all available network interfaces. -->
    <HarfsLocalAddress Condition="'$(HarfsLocalAddress)' == ''"></HarfsLocalAddress>

    <!-- Default to a random unused TCP port. -->
    <HarfsPort Condition="'$(HarfsPort)' == ''">0</HarfsPort>

    <!-- Generate a new secret. -->
    <HarfsSecret Condition="'$(HarfsSecret)' == ''"></HarfsSecret>
    <HarfsSecretBase64 Condition="'$(HarfsSecretBase64)' == ''"></HarfsSecretBase64>

    <!-- Generate a new self-signed certificate. -->
    <HarfsCertificateFile Condition="'$(HarfsCertificateFile)' == ''"></HarfsCertificateFile>

    <!-- Limit recursive directory reads to 256 files. -->
    <HarfsMaxSearchDepth Condition="'$(HarfsMaxSearchDepth)' == ''">256</HarfsMaxSearchDepth>

    <!-- Automatically shut down HARFS if no client connects within a 5-minute window. -->
    <HarfsTimeout Condition="'$(HarfsTimeout)' == ''">300000</HarfsTimeout>

    <!-- Automatically shut down HARFS when its primary client disconnects. -->
    <HarfsExitOnDisconnect Condition="'$(HarfsExitOnDisconnect)' == ''">true</HarfsExitOnDisconnect>

    <!-- Save HARFS config to `Path.Combine(IntermediateOutputPath, "/Avalonia/HotAvalonia.Remote.xml")`. -->
    <HarfsConfigOutputPath Condition="'$(HarfsConfigOutputPath)' == ''">Avalonia\HotAvalonia.Remote.xml</HarfsConfigOutputPath>
  </PropertyGroup>

  <PropertyGroup>
    <!-- This is pretty self-explanatory: -->
    <!-- Define the constants used by `AvaloniaHotReloadExtensions.(cs|vb|fs)` based on the current settings. -->
    <DefineConstants Condition="'$(HotAvalonia)' == 'true'">$(DefineConstants)$(_HotAvaloniaDefineConstantsSeparator)HOTAVALONIA_ENABLE</DefineConstants>
    <DefineConstants Condition="'$(HotAvaloniaRemote)' == 'true'">$(DefineConstants)$(_HotAvaloniaDefineConstantsSeparator)HOTAVALONIA_USE_REMOTE_FILE_SYSTEM</DefineConstants>
    <DefineConstants Condition="'$(HotAvaloniaLite)' == 'true'">$(DefineConstants)$(_HotAvaloniaDefineConstantsSeparator)HOTAVALONIA_ENABLE_LITE</DefineConstants>
    <DefineConstants Condition="'$(HotAvaloniaIncludeExtensions)' != 'true'">$(DefineConstants)$(_HotAvaloniaDefineConstantsSeparator)HOTAVALONIA_EXCLUDE_EXTENSIONS</DefineConstants>
  </PropertyGroup>

  <PropertyGroup>
    <!-- For MSBuild `>= 17.0.0`, we want to use `TargetsTriggeredByCompilation` instead of `AfterTargets`, -->
    <!-- because the latter and the older one basically doesn't work with incremental builds. -->
    <MSBuildMajorVersion Condition="'$(MSBuildMajorVersion)' == '' And '$(MSBuildVersion)' != ''">$([System.Version]::Parse($(MSBuildVersion)).Major)</MSBuildMajorVersion>
    <MSBuildMajorVersion Condition="'$(MSBuildMajorVersion)' == ''">15</MSBuildMajorVersion>
    <HotAvaloniaAfterTargets Condition="($(MSBuildMajorVersion) &lt; 17) AND '$(HotAvaloniaAfterTargets)' == ''">AfterCompile</HotAvaloniaAfterTargets>
    <TargetsTriggeredByCompilation Condition="'$(HotAvaloniaAfterTargets)' == ''">$(TargetsTriggeredByCompilation);HotAvaloniaGenerateFileSystemServerConfig</TargetsTriggeredByCompilation>

    <!-- Ensure our target runs only when `CompileAvaloniaXaml` has completed. -->
    <HotAvaloniaDependsOnTargets Condition="'$(HotAvalonia)' == 'true'">$(HotAvaloniaDependsOnTargets);CompileAvaloniaXaml</HotAvaloniaDependsOnTargets>

    <!-- If remote hot reload is enabled, Fody must run after our target generates a proper config for it. -->
    <FodyDependsOnTargets Condition="'$(HotAvalonia)' == 'true' And '$(HotAvaloniaRemote)' == 'true'">$(FodyDependsOnTargets);HotAvaloniaGenerateFileSystemServerConfig</FodyDependsOnTargets>

    <!-- Otherwise, ensure that Fody runs only after Avalonia has finished compiling XAML. -->
    <FodyDependsOnTargets Condition="'$(HotAvalonia)' == 'true' And '$(HotAvaloniaRemote)' != 'true'">$(FodyDependsOnTargets);CompileAvaloniaXaml</FodyDependsOnTargets>
  </PropertyGroup>

  <!-- This is the default Fody config for scenarios where remote hot reload is disabled. -->
  <PropertyGroup Condition="'$(HotAvaloniaRemote)' != 'true'">
    <WeaverConfiguration>
      <Weavers>
        <HotAvalonia SolutionPath="$(SolutionPath)">
          <PopulateOverride Enable="$(HotAvaloniaRecompileResources)" />
          <UseHotReload Enable="$(HotAvaloniaAutoEnable)" GeneratePathResolver="$(HotAvaloniaGeneratePathResolver)" />
        </HotAvalonia>
      </Weavers>
    </WeaverConfiguration>
  </PropertyGroup>

  <PropertyGroup>
    <!-- We cannot provide a sensible default for `AvaloniaVersion`, as it must match -->
    <!-- the exact Avalonia version used in the current environment. -->
    <!-- So, we'll deal with this later. -->
    <AvaloniaVersion Condition="'$(AvaloniaVersion)' == ''"></AvaloniaVersion>

    <!-- Since Fody will only be referenced when custom weavers are provided (e.g., in our testing environment), -->
    <!-- we are not concerned about the wildcard breaking things. -->
    <FodyVersion Condition="'$(FodyVersion)' == ''">*</FodyVersion>

    <!-- Almost nobody uses `MonoMod` in their Avalonia apps, so it's actually beneficial to always -->
    <!-- install the latest version, as it needs to be updated every time a new .NET version is released. -->
    <MonoModRuntimeDetourVersion Condition="'$(MonoModRuntimeDetourVersion)' == ''">*</MonoModRuntimeDetourVersion>
  </PropertyGroup>

  <!-- `HotAvalonia.Extensions` should always be accessible, as it contains the definitions of -->
  <!-- `AvaloniaHotReloadAttribute` and `AvaloniaHotReloadExtensions`. -->
  <ItemGroup>
    <PackageReference Condition="'$(_HotAvaloniaExtensionsFile)' == ''" Include="HotAvalonia.Extensions" Version="$(HotAvaloniaVersion)" PrivateAssets="All" />
    <Compile Condition="'$(_HotAvaloniaExtensionsFile)' != ''" Include="$(_HotAvaloniaExtensionsFile)" Link="AvaloniaHotReloadExtensions.cs" Visible="False" />
  </ItemGroup>

  <!-- `HotAvalonia.Core` and `HotAvalonia.Fody` must be included **only** when hot reload is enabled. -->
  <ItemGroup Condition="'$(HotAvalonia)' == 'true'">
    <PackageReference Condition="'$(_HotAvaloniaCoreProjectFile)' == ''" Include="HotAvalonia.Core" Version="$(HotAvaloniaVersion)" />
    <ProjectReference Condition="'$(_HotAvaloniaCoreProjectFile)' != ''" Include="$(_HotAvaloniaCoreProjectFile)" />

    <PackageReference Condition="'$(_HotAvaloniaWeaverFiles)' == ''" Include="HotAvalonia.Fody" Version="$(HotAvaloniaVersion)" PrivateAssets="All" />
    <PackageReference Condition="'$(_HotAvaloniaWeaverFiles)' != ''" Include="Fody" Version="$(FodyVersion)" PrivateAssets="All" />
    <WeaverFiles Condition="'$(_HotAvaloniaWeaverFiles)' != ''" Include="$(_HotAvaloniaWeaverFiles)" />
  </ItemGroup>

  <!-- `Avalonia.Markup.Xaml.Loader` and `MonoMod.RuntimeDetour` only need to be referenced once, -->
  <!-- as they are effectively shadow dependencies. -->
  <!-- So, it makes sense to include them in the startup project only. -->
  <ItemGroup Condition="'$(HotAvalonia)' == 'true' And '$(_HotAvaloniaIsExe)' == 'true'">
    <PackageReference Condition="'$(AvaloniaVersion)' != ''" Include="Avalonia.Markup.Xaml.Loader" Version="$(AvaloniaVersion)" />
    <PackageReference Condition="'$(HotAvaloniaUseInjections)' == 'true'" Include="MonoMod.RuntimeDetour" Version="$(MonoModRuntimeDetourVersion)" PrivateAssets="All" />
  </ItemGroup>

  <!-- If we need `Avalonia.Markup.Xaml.Loader`, but `AvaloniaVersion` has not been resolved yet, -->
  <!-- we must manually find any Avalonia-related package referenced in the current project and use its version. -->
  <Target
    Name="HotAvaloniaInstallAvaloniaMarkupXamlLoader"
    Condition="'$(AvaloniaVersion)' == '' And '$(HotAvalonia)' == 'true' And '$(_HotAvaloniaIsExe)' == 'true'"
    BeforeTargets="CollectPackageReferences;CollectCentralPackageVersions"
  >
    <!-- Avalonia has reserved its prefix on NuGet, so any package that starts with `Avalonia.` (or is just `Avalonia`) -->
    <!-- is an Avalonia package. Since all their packages are kept in sync, we can use the version of any Avalonia package we find. -->
    <CreateProperty
      Value="%(PackageReference.Version)"
      Condition="'%(PackageReference.Identity)' == 'Avalonia' Or $([System.String]::new('%(PackageReference.Identity)').StartsWith('Avalonia.'))"
    >
      <Output TaskParameter="Value" PropertyName="AvaloniaVersion" />
    </CreateProperty>

    <!-- If no Avalonia-related package is found, emit a warning to inform the user about this kerfuffle, -->
    <!-- default to the minimum supported Avalonia version, and pray that nothing breaks. -->
    <Warning
      Condition="'$(AvaloniaVersion)' == ''"
      Text="Unable to determine the Avalonia version. Please set the 'AvaloniaVersion' property. Defaulting to '$(HotAvaloniaMinimumSupportedAvaloniaVersion)'."
    />
    <ItemGroup>
      <PackageReference Condition="'$(AvaloniaVersion)' == ''" Include="Avalonia.Markup.Xaml.Loader" Version="[$(HotAvaloniaMinimumSupportedAvaloniaVersion),)]" />
      <PackageReference Condition="'$(AvaloniaVersion)' != ''" Include="Avalonia.Markup.Xaml.Loader" Version="$(AvaloniaVersion)" />
    </ItemGroup>
  </Target>

  <!-- If remote hot reload is enabled, we need to generate a HARFS config, -->
  <!-- and then pass the connection information to the app via a weaver. -->
  <Target
    Name="HotAvaloniaGenerateFileSystemServerConfig"
    Condition="'$(HotAvalonia)' == 'true' And '$(HotAvaloniaRemote)' == 'true'"
    AfterTargets="$(HotAvaloniaAfterTargets)"
    DependsOnTargets="$(HotAvaloniaDependsOnTargets)"
    Inputs="@(IntermediateAssembly);$(ProjectWeaverXml)"
    Outputs="$(IntermediateOutputPath)$(HarfsConfigOutputPath)"
  >
    <!-- Generate a config. -->
    <HotAvalonia.GenerateFileSystemServerConfigTask
      Root="$(SolutionDir)"
      FallbackRoot="$(MSBuildProjectDirectory)"
      Secret="$(HarfsSecretBase64)"
      SecretUtf8="$(HarfsSecret)"
      Address="$(HarfsLocalAddress)"
      Port="$(HarfsPort)"
      Certificate="$(HarfsCertificateFile)"
      MaxSearchDepth="$(HarfsMaxSearchDepth)"
      Timeout="$(HarfsTimeout)"
      AllowShutDownRequests="$(HarfsExitOnDisconnect)"
      OutputPath="$(IntermediateOutputPath)$(HarfsConfigOutputPath)"
    />

    <!-- Read the config and save its values into properties. -->
    <HotAvalonia.GetFileSystemClientConfigTask
      FileSystemServerConfigPath="$(IntermediateOutputPath)$(HarfsConfigOutputPath)"
      Address="$(HarfsAddress)"
      FallbackAddress="$(HarfsFallbackAddress)"
    >
      <Output TaskParameter="Address" PropertyName="HarfsAddress" />
      <Output TaskParameter="Port" PropertyName="HarfsPort" />
      <Output TaskParameter="Secret" PropertyName="HarfsSecretBase64" />
    </HotAvalonia.GetFileSystemClientConfigTask>

    <!-- Pass those values to the app. -->
    <PropertyGroup>
      <WeaverConfiguration>
        <Weavers>
          <HotAvalonia SolutionPath="$(SolutionPath)">
            <PopulateOverride Enable="$(HotAvaloniaRecompileResources)" />
            <UseHotReload Enable="$(HotAvaloniaAutoEnable)" GeneratePathResolver="$(HotAvaloniaGeneratePathResolver)" />
            <FileSystemCredentials Enable="true" Address="$(HarfsAddress)" Port="$(HarfsPort)" Secret="$(HarfsSecretBase64)" />
          </HotAvalonia>
        </Weavers>
      </WeaverConfiguration>
    </PropertyGroup>
  </Target>

  <!-- If remote hot reload is enabled, start HARFS when the build completes. -->
  <Target Name="HotAvaloniaStartFileSystemServer"
    Condition="'$(HotAvalonia)' == 'true' And '$(HotAvaloniaRemote)' == 'true'"
    AfterTargets="AfterBuild"
  >
    <HotAvalonia.StartFileSystemServerTask
      FileSystemServerPath="$(_HotAvaloniaHarfsFile)"
      FileSystemServerConfigPath="$(IntermediateOutputPath)$(HarfsConfigOutputPath)"
      DotnetPath="$(DOTNET_HOST_PATH)"
    />
  </Target>

</Project>
